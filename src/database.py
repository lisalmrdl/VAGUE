import os, pickle
import pandas as pd
import sqlite3 as sql
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from pprint import pprint
from flask import g
import matplotlib.pyplot as plt
import numpy as np
plt.style.use('ggplot')

####### GLOBAL VARIABLES ######
path = Path(os.path.abspath(os.path.dirname(__file__)))
db_path = path / ".." / "data" / "games.db" # path to the database (from this script)

####### FUNCTIONS #######
def get_db():
    """Intended use is private (inside this script). Opens a new connection to the database for flask use, thread safe.

    Returns:
        flask.g: This contains the database connection
    """
    if "db" not in g:
        g.db = sql.connect(db_path)
        g.db.row_factory = sql.Row
    return g.db

def plot_ratings(ids: list, output_file=path / ".." / ".temp" / "ranking.png"):
    """Gets a list of game ids and creates a plot with the rating of the games associated with the ids. The plot is sorted and has 10 evenly spaced bins. The plot is saved as a png image. It's possible to give a path to a file to save the image in such location, look at the arguments.

    Args:
        ids (list): list containing the games' ids
        output_file (_type_, optional): Path to the file where the plot image will be saved. Defaults to ./../.temp/ranking.png
    """
    data = pd.read_sql(get_all_gamedata(ids=ids, as_text=True), get_db())["rating"]
    plt.figure()
    plt.hist(data, bins=np.linspace(0, 5, 11),color="red",edgecolor="white")
    plt.xticks(range(6))
    plt.xlabel("Rating")
    plt.ylabel("Frequency")
    plt.title("Rating distribution")
    plt.savefig(output_file)
    plt.close()

def plot_genre_pie(ids: list, output_file=path / ".." / ".temp" / "genres_pie.png", top_n = 7):
    """Gets a list of game ids and creates a pie chart with the genres of the games. The plot is sorted and has 10 evenly spaced bins. The chart is saved as a png image. It's possible to give a path to a file to save the image in such location, look at the arguments.

    Args:
        ids (list): list containing the games' ids
        output_file (_type_, optional): Path to the file where the plot image will be saved. Defaults to ./../.temp/ranking.png
        top_n (int): Only the top n will be displayed, the others will be displayed as "Other". Defaults to 7.
    """
    data = pd.read_sql(get_genres(ids=ids, as_text=True), get_db())
    counts = pd.Series(data["count"].iloc[:top_n].tolist(), index=data["genres"][:top_n])
    counts["Other"] = sum(data["count"][top_n:])
    del data
    cmap = plt.cm.hsv
    colors = cmap(np.linspace(0, 1, 5))
    plt.figure()
    plt.pie(
        counts,
        labels=counts.index,
        autopct="%1.1f%%",
        startangle=90,
        counterclock=False,
        wedgeprops={"edgecolor": "black"},
        colors=colors
    )
    plt.title("Genre distribution")
    plt.axis("equal")
    plt.savefig(output_file)
    plt.close()

def get_genres(ids, as_text=False):
    cur = get_db()
    query = """SELECT
                    gen.name AS genres,
                    COUNT(x.id_game) as count
                FROM has_genre x
                JOIN genre gen ON gen.id_genre = x.id_genre
            """
    if len(ids) > 1:
        query+=f"WHERE x.id_game IN {tuple(map(str, ids))}"
    else:
        query+=f"WHERE x.id_game == {tuple(map(str, ids))[0]}"
    query+="\nGROUP BY gen.name"
    query+="\nORDER BY count DESC"
    if as_text:
        return query
    else:
        return cur.execute(query).fetchall()

def close_db(e=None):
    """Close the connection with the database
    """
    db = g.pop("db", None)
    if db is not None:
        db.close()

def deserialize(compressed_data):
    """Deserializes data from bytes

    Args:
        compressed_data (bytes): compressed data

    Returns:
        Any: Whatever object the data contains
    """
    return pickle.loads(compressed_data)

def load_pickle_file(path):
    """Load a pickle file and deserialize it.

    Args:
        path (str): Path to the file

    Returns:
        Any: Whatever object the data contains
    """
    return pickle.load(open(path, "rb"))

def load_boolean_vectors() -> dict[str, pd.DataFrame]:
    """Loads the boolean vectors from the serialized file and returns it in a dict format. The values are Dataframes.

    Returns:
        dict[str, pd.DataFrame]: Dict with boolean vectors.
    """
    return load_pickle_file(path / ".." / "data" / "boolean_vectors")

def load_tfidf_vectors() -> pd.DataFrame:
    """Loads the tf-idf vectors from the serialized file and returns it in a pd.DataFrame.

    Returns:
        pd.DataFrame: tf-idf vectors indexed on the game ids and with the tokens as columns.
    """
    return load_pickle_file(path / ".." / "data" / "tf_idf")

def load_neural_embeddings() -> pd.DataFrame:
    """Loads the embedding generated by the transformer model from the serialized file and returns it in a pd.DataFrame. The embeddings have been generated with the following model: sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2.

    Returns:
        pd.DataFrame: Embeddings indexed on the game ids and with just numbers as column names. just use dataframe.loc[id_game] to get an embedding as a pd.Series().
    """
    return load_pickle_file(path / ".." / "data" / "neural_embeddings")

def get_text_gamedata(limit = 0, as_text = False):
    """Fetch all textual data from the SQL database.

    Args:
        limit (int): Limit the query only to a set number of items. Intended for debugging.
        as_text (bool): If true returns the query as a string so it can be used with pd.read_sql.

    Returns:
        list[str] or str: Results of the query or the query string.
    """
    cur = get_db()
    idgame_join_genres = """SELECT
                              x.id_game,
                              GROUP_CONCAT(gen.name, ', ') AS genres
                          FROM has_genre x
                          JOIN genre gen ON gen.id_genre = x.id_genre
                          GROUP BY x.id_game"""
    idgame_join_developers = """SELECT
                                d.id_game,
                                GROUP_CONCAT(c.name, ', ') AS developers
                            FROM developed d
                            JOIN company c ON c.id_company = d.id_company
                            GROUP BY d.id_game"""
    idgame_join_publishers = """SELECT
                                p.id_game,
                                GROUP_CONCAT(c.name, ', ') AS publishers
                            FROM published p
                            JOIN company c ON c.id_company = p.id_company
                            GROUP BY p.id_game"""
    q = f"""SELECT
            g.id_game as id_game,
            g.name as name,
            gen.genres as genres,
            g.description as description,
            dev.developers as developers,
            pub.publishers as publishers
            FROM game g JOIN ({idgame_join_genres}) gen ON gen.id_game == g.id_game
            JOIN ({idgame_join_developers}) dev ON dev.id_game == g.id_game
            JOIN ({idgame_join_publishers}) pub ON pub.id_game == g.id_game
            ORDER BY g.metacritic DESC"""
    if limit > 0:
        q += f" LIMIT {limit}"
    if as_text:
        return q
    else:
        return cur.execute(q).fetchall()
    
def get_similarity_weigths(game_ids, normalized=True):
    """
    Fetch the appropriate columns from the database from which the similarity is weighted (the search should take into account the similarity together with the popularity of a game for the search results). For now the similarity should be weighted using the rating and the amount of ratings, this function returns a dataframe containing these as columns. The dataframe is normalized by default (using the max value as a reference for the division).

    Args:
        game_ids (list[int]): ids from the games whose ratings and rating count should be retrieved.
        normalized (bool): Should the values be normalized by max value (True) or should the values be returned as they are (False)?. Defaults to True.

    Returns:
        pd.DataFrame: Dataframe indexed with the games' ids containing the rating and the ratings_count as the columns.
    """
    cur = get_db()
    q = f"""SELECT
            id_game,
            ratings_count,
            rating
            FROM game
            """
    if len(game_ids) > 1:
        q+=f"WHERE id_game IN {tuple(map(str, game_ids))}"
    else:
        q+=f"WHERE id_game == {tuple(map(str, game_ids))[0]}"
    result = pd.read_sql(q, cur, index_col="id_game")
    if normalized:
        result["ratings_count"] = result["ratings_count"]/result["ratings_count"].max()
        result["rating"] = result["rating"]/result["rating"].max()
    return result
    
def get_all_gamedata(limit = 0, as_text = False, ids=None, cur = None):
    """Fetch all useful data from the games from the SQL database.

    Args:
        limit (int): Limit the query only to a set number of items. Intended for debugging.
        as_text (bool): If true returns the query as a string so it can be used with pd.read_sql.
        ids (list[int]): Restrict the query to a set of game ids. This is intended so the vector computations are performed in the dataframes and the the indexes of the dataframes are used to fetch the data.

    Returns:
        list[str] or str: Results of the query or the query string.
    """
    if cur == None:
        cur = get_db()
    idgame_join_genres = """SELECT
                              x.id_game,
                              GROUP_CONCAT(gen.name, ', ') AS genres
                          FROM has_genre x
                          JOIN genre gen ON gen.id_genre = x.id_genre
                          GROUP BY x.id_game"""
    idgame_join_developers = """SELECT
                                d.id_game,
                                GROUP_CONCAT(c.name, ', ') AS developers
                            FROM developed d
                            JOIN company c ON c.id_company = d.id_company
                            GROUP BY d.id_game"""
    idgame_join_publishers = """SELECT
                                p.id_game,
                                GROUP_CONCAT(c.name, ', ') AS publishers
                            FROM published p
                            JOIN company c ON c.id_company = p.id_company
                            GROUP BY p.id_game"""
    q = f"""SELECT
            g.id_game as id_game,
            g.name as name,
            gen.genres as genres,
            g.description as description,
            dev.developers as developers,
            pub.publishers as publishers,
            g.image_url as image_url,
            g.website_url as website_url,
            g.units_sold as units_sold,
            g.rating as rating,
            g.ratings_count as ratings_count,
            g.metacritic as metacritic,
            g.released as release_date
            FROM game g JOIN ({idgame_join_genres}) gen ON gen.id_game == g.id_game
            JOIN ({idgame_join_developers}) dev ON dev.id_game == g.id_game
            JOIN ({idgame_join_publishers}) pub ON pub.id_game == g.id_game
            """
    if ids != None:
        if len(ids) > 1:
            q += f"WHERE g.id_game IN {tuple(map(str, ids))}"
        else:
            q += f"WHERE g.id_game == {str(ids[0])}"
    if limit > 0:
        q += f" LIMIT {limit}"
    if as_text:
        return q
    else:
        return cur.execute(q).fetchall()


if __name__=="__main__":
    pass